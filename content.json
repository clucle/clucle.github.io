{"meta":{"title":"clucle's blog","subtitle":"두찡의 프로그래밍","description":"두찡의 일상","author":"Dujin Jung","url":"http://clucle.github.io"},"pages":[],"posts":[{"title":"Retrofit-HTTP-Android","slug":"Retrofit-HTTP-Android","date":"2017-05-19T07:00:03.000Z","updated":"2017-05-19T07:00:36.208Z","comments":true,"path":"2017/05/19/Retrofit-HTTP-Android/","link":"","permalink":"http://clucle.github.io/2017/05/19/Retrofit-HTTP-Android/","excerpt":"","text":"Retrofit 은 안드로이드와 자바에서 HTTP client 에서 REST API통신을 하기 위한 라이브러리이다. 공식 홈페이지. 이번에는 간단한 node server와 android client 의 HTTP 통신을 하는 간단한 예제를 소개하려고 한다. 소스코드는 link를 첨부한다. server repository에는 node server가 들어있고, client repository에는 android client가 들어있다. 이 글에서는 Server 보다는 Retrofit 에 집중 하므로 서버에 관한 내용은 간단하게만 소개한다. ServerServer는 nodejs로 작성 할 필요는 없다. 단지 HTTP 통신을 확인하기 위한 소스이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445var express = require('express');var http = require('http');var path = require('path');var app = express();var bodyParser = require('body-parser');// parse JSON inputsapp.use(bodyParser.json());// parse URL encoded inputsapp.use(bodyParser.urlencoded());app.set('port', process.env.PORT || 3000);app.get('/', function(req, res)&#123; res.sendFile(__dirname + '/index.html');&#125;);app.post('/ping', function(req, res)&#123; res.status(200).send(\"pong\");&#125;);app.post('/user/one', function(req, res)&#123; if (req.body.name == \"clucle\") &#123; res.status(200).send(&#123;name: 'clucle', age: 23&#125;); &#125; else if(req.body.name == \"junsu\") &#123; res.status(200).send(&#123;name: 'junsu', age: 25&#125;); &#125; else &#123; res.status(404).send(\"ERROR\"); &#125;&#125;);app.post('/user/list', function(req, res)&#123; res.status(200).send(&#123;users: [ &#123;name: 'clucle', age: 23&#125;, &#123;name: 'junsu', age: 25&#125; ]&#125;);&#125;);http.createServer(app).listen(app.get('port'), function()&#123; console.log('Express server listeneing on port ' + app.get('port'));&#125;) 이 소스에서 중요한 부분은 app.post 라고 쓰여진 부분 중에서 /user/ 으로 접근하는 부분이다. client 에서 user/one 으로 접근 할 때는 req.body.name 에 이름을 받아서 검색한다. body 는 json 형식으로 {“name”: “something”} 보내주면 파싱한다. client 에서 user/list 으로 접근 할 때는 파라미터 없이 users 리스트를 전달해준다. body 는 json 형식으로 {“name”: “something”} 보내주면 파싱한다. res.send(code) 에서 code 는 일반적으로 200번이 성공이고 400대가 넘어가면 관리자가 적용해둔 에러로 처리하고 client에서 200번에 왔을 때 통신을 처리하고, 에러코드가 넘어오면 에러처리를 해주면 된다. Client1. gradle setting app의 build.gradle에 다음 소스를 추가한다. 우리가 주목해야 하는 부분은 아래와 같다. 이글의 작성 시점 2017-05-19의 최신 버전 2.3.0 버전을 사용하였다. compile ‘com.squareup.retrofit2:retrofit:2.3.0’compile ‘com.squareup.retrofit2:converter-gson:2.3.0’ 1234567891011121314151617181920212223242526272829303132apply plugin: 'com.android.application'android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.3\" defaultConfig &#123; applicationId \"com.android_dev.clucle.retrofittutor\" minSdkVersion 18 targetSdkVersion 25 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.2' compile 'com.squareup.retrofit2:retrofit:2.3.0' compile 'com.squareup.retrofit2:converter-gson:2.3.0' testCompile 'junit:junit:4.12'&#125; 2. example우선 통신을 하는 API를 정해서 미리 정의한다. POST 명령으로 user/one을 실행하면 name을 인자로 줘서 User class에 맞는 json을 받는다. 주는 형식은 {“name”: name} 으로 전달된다 POST 명령으로 user/list를 실행하면 인자 없이 Users class에 맞는 json을 받는다. @FormUrlEncoded는 json 인자를 서버에 보내줘야할 때 써준다. 1234567891011public interface RetrofitAPI &#123; @POST(&quot;user/one&quot;) @FormUrlEncoded Call&lt;User&gt; getUser( @Field(&quot;name&quot;) String name ); @POST(&quot;user/list&quot;) Call&lt;Users&gt; getUserList();&#125; 123456789101112131415161718192021222324252627282930public class User &#123; private String name; private int age; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return (&quot;name : &quot; + name + &quot; age : &quot; + age); &#125;&#125; 123public class Users &#123; public List&lt;User&gt; users;&#125; 정의해둔 HTTP API 통신을 하기 위해서 Retrofit 의 Builder로 서버와 통신한다. 이를 편하게 하기 위해서 RetrofitHelper를 제작한다. 아래 url과 port는 내 로컬 pc의 ip와 node서버를 열어둔 포트이다. getInstance() Method를 통해 어디서나 통신을 할 수 있도록 만들고 retrofit.create에서 위에서 만든 API를 넣어주면 서버와 통신한다. 12345678910111213141516171819202122232425public class RetrofitHelper &#123; // server address, port private final static String url = &quot;http://192.168.0.22&quot;; private final static int port = 3000; private static Retrofit retrofit; public static RetrofitAPI getInstance() &#123; if (retrofit == null) &#123; retrofit = new Retrofit.Builder() .baseUrl(url + &quot;:&quot; + port) .addConverterFactory(GsonConverterFactory.create()) .build(); &#125; return retrofit.create(RetrofitAPI.class); &#125; public static boolean returnNetworkState(Context context) &#123; ConnectivityManager connectivityManager = ((ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE)); return connectivityManager.getActiveNetworkInfo() != null &amp;&amp; connectivityManager.getActiveNetworkInfo().isConnected(); &#125;&#125; 3. start retrofit만들어둔 RetrofitHelper와 API로 통신하는 법이다. RetrofitHelper.getInstance().에서 Interface에 정의해둔 함수명을 적는다. RetrofitHelper.getInstance().Method(parameter).enque(new Callback&lt;인터페이스에서 정한 받을 타입&gt;(){ 여기에서 엔터 치고 명령어들을 override한다. }) 그러면 onResponse와 onFailure에 나오는데 onResponse는 서버에서 어떤 값이 넘어온 상태이고 onFailure는 서버에서 값이 넘어오지 않은 상태이거나, 너무 많은 요청이 들어간 등 서버에서 에러가 난 상태이다. onResponse에서 code가 에러코드가 아니지 체크하고 response.code() == 200 response.body()는 내부에 json파일이 들어있는지 확인한다 response.body() != null 만약 Model Class 여기서는 User 에 getter를 만들어 두었으면 json형식의 파일을 맞춰서 받으면 자동으로 파싱되서 들어간다. 잘 모르겠으면 소스를 위에 링크한 소스를 참고하면 편할 것이다. updateUserList에서는 updateUser와 다르게 json이 배열 형식으로 오는데 받는 json 형식이 현재 {users: [{“name”:”name1”,”age”:”age1”},{“name”:”name2”,”age”:”age2”}]}배열에 담겨서 온다. 이럴 때는 response.body().users로 해주면 json의 users에 담긴 배열을 받아와서 List에 넣을 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class RetrofitPresenter &#123; private View view; private User user; private List&lt;User&gt; userList; // Constructor public RetrofitPresenter(View view) &#123; this.view = view; &#125; // Search One User and Show View public void updateUser(String name) &#123; Log.e(&quot;[Client]&quot;, &quot;Too many request?&quot;); RetrofitHelper.getInstance().getUser(name).enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(@NonNull Call&lt;User&gt; call, @NonNull Response&lt;User&gt; response) &#123; if (response.code() == 200 &amp;&amp; response.body() != null) &#123; user = response.body(); view.updateTextView(user.toString()); &#125; else &#123; onFailure(call, new Throwable(&quot;may be response something but error&quot;)); &#125; &#125; @Override public void onFailure(@NonNull Call&lt;User&gt; call, @NonNull Throwable t) &#123; Log.e(&quot;[Server]&quot;, t.getLocalizedMessage()); view.updateTextView(&quot;Error! at Search One&quot;); &#125; &#125;); &#125; // Search User List and Show View public void updateUserList() &#123; RetrofitHelper.getInstance().getUserList().enqueue(new Callback&lt;Users&gt;() &#123; @Override public void onResponse(@NonNull Call&lt;Users&gt; call, @NonNull Response&lt;Users&gt; response) &#123; if (response.code() == 200 &amp;&amp; response.body().users != null) &#123; userList = response.body().users; // 임시로 2번 째 사람의 이름만 출력해보자 view.updateTextView(userList.get(1).getName()); &#125; else &#123; onFailure(call, new Throwable(&quot;may be response something but error&quot;)); &#125; &#125; @Override public void onFailure(@NonNull Call&lt;Users&gt; call, @NonNull Throwable t) &#123; Log.e(&quot;[Server]&quot;, t.getLocalizedMessage()); view.updateTextView(&quot;Error! at Search List&quot;); &#125; &#125;); &#125; public interface View &#123; void updateTextView(String text); &#125;&#125; Retrofit REST API Android 후기 이번에 해커톤 대회에서 새로 배워온 내용이라 써보면서 편하다고 느꼇고, 글만 봐서는 어떤 내용인지 잘 모를 것 같고 한번 써보면 쉽게 사용 할 수 있는 좋은 라이브러리 인 것 같다.","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://clucle.github.io/tags/android/"}]},{"title":"MVP-Pattern-Android","slug":"MVP-Pattern-Android","date":"2017-05-18T05:17:51.000Z","updated":"2017-05-18T06:50:46.820Z","comments":true,"path":"2017/05/18/MVP-Pattern-Android/","link":"","permalink":"http://clucle.github.io/2017/05/18/MVP-Pattern-Android/","excerpt":"","text":"MVP Pattern 이란 MVC 아키텍처 패턴에서 파생된 것으로 User Interface를 작성하는데 사용된다. MVP는 (Model-View-Presenter)의 약자이다. 기존에 작성했던 소스를 예시로 MVP Pattern의 예시를 들어보려고 한다. 소스코드는 링크를 첨부한다. source MVP Pattern flow 위의 그림을 토대로 설명을 해보겠다. ViewMVP Pattern에서 View란 activity 혹은 Fragment 에서 사용자가 보고있는 화면을 의미한다. View를 보는 사용자는 굳이 내부에서 실행 될 로직이나, 변수에는 전혀 의존성 없이 할 행동만 있으면 된다. PresenterPresenter 란 View와 Model 사이를 연결해주는 곳이다. View에서 User의 Action이 들어오면 데이터에 의존성이 있다면 데이터를 수정하고 없다면 데이터를 수정 하지 않는다. User Action 에 맞는 Method를 실행하고 View에 모든 명령을 다 처리 한 후 사용자에게 보여질 View를 udpate 해준다. ModelModel 이란 사용자 저장되어 있는 정보가 필요 할 때 사용한다. 예를 들면 사람 정보를 저장한다고 하면, 사람에 관한 데이터를 DB로 저장하던지 Local 변수로 저장 할 것이다. Simple source이 소스는 View에서 사용자의 입력을 받아 Model(user) 에 이름을 저장하는 간단한 예제이다. PresenterPresenter 부터 살펴보자. Presenter 는 Model과 View 모두 연결 되있다. Presenter에 View라는 interface를 만들어두고 View에서 Presenter.View를 implements 하는 것으로 View에서 rendering 될 View에대한 Method를 override할 의무를 준다. updateName 은 View에서 사용자가 요청할 Method이고 요청이 들어오면 Model에 데이터를 저장하고 View에 update를 요청한다. 12345678910111213141516171819public class MainPresenter &#123; private User user; private View view; public MainPresenter(View view) &#123; this.view = view; user = new User(); &#125; public void updateName(String name) &#123; user.setName(name); view.updateUserInfoTextView(user.toString()); &#125; public interface View &#123; void updateUserInfoTextView(String info); &#125;&#125; ModelModel 에서는 사용자가 필요한 정보를 저장할 class가 필요하다12345678910111213public class User &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Name : &quot; + name; &#125;&#125; ViewView 에서는 Presenter의 View를 implements받아 View에서 사용해야 하는 Method를 override 한다. onCreate시 presenter를 등록 해 주고, 사용자의 행동은 Presenter로 보내준다. 여기에서는 text가 변경 될 때 Presenter에 사용자의 행동을 보낸다. 12345678910111213141516171819202122232425262728293031323334353637383940public class MainActivity extends AppCompatActivity implements MainPresenter.View&#123; private MainPresenter mainPresenter; private TextView userInfoTextView; private EditText name; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mainPresenter = new MainPresenter(this); userInfoTextView = (TextView) findViewById(R.id.userInfo); name = (EditText) findViewById(R.id.name); name.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; mainPresenter.updateName(s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123; &#125; &#125;); &#125; @Override public void updateUserInfoTextView(String info) &#123; userInfoTextView.setText(info); &#125;&#125; MVP-Pattern 후기 사용자 입장과 개발자 입장을 나누어서 볼 수 있다는 점이 편한 것 같다. 다른 여러 디자인 패턴에 대한 정보도 궁금하다.","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://clucle.github.io/tags/android/"}]},{"title":"Data Binding? ButterKnife? 뭐하는 거에요?","slug":"data-binding-butterknife","date":"2017-05-10T16:18:14.000Z","updated":"2017-05-10T17:28:10.240Z","comments":true,"path":"2017/05/11/data-binding-butterknife/","link":"","permalink":"http://clucle.github.io/2017/05/11/data-binding-butterknife/","excerpt":"","text":"Data Binding과 ButterKnife, 안드로이드를 처음 접하는 사람에겐 생소한 이름일 것이다. Data Binding과 ButterKnife 안드로이드에서 데이터 바인딩를 도와주는 library이다. 안드로이드에서 데이터 바인딩이란 무엇일까? 바로 UI와 데이터간을 서로 연결하는 프로세스이다. 그렇다면 왜 이러한 라이브러리를 사용하는 것일까? 아래 라이브러리를 사용하지 않았을 때와 그렇지 않을 때의 차이점을 간단하게 살펴보자. 데이터 바인딩을 사용하지 않았을 경우라이브러리를 사용하지 않았을 때의 코드를 살펴보자. 아래 예시는 안드로이드에 처음 접할 때 만들었던 소스 중 일부를 첨부한다. source 12345678910111213141516171819202122232425262728293031323334353637383940// xml 소스 중 일부&lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"0px\" android:layout_weight=\"38\" android:background=\"#8B4513\" android:orientation=\"vertical\" android:paddingBottom=\"2dp\" android:paddingLeft=\"16dp\" android:paddingRight=\"16dp\" android:paddingTop=\"2dp\"&gt; &lt;Button android:id=\"@+id/btn_add\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentStart=\"true\" android:layout_centerVertical=\"true\" android:layout_marginLeft=\"4dp\" android:text=\"Add\" android:textStyle=\"bold\" /&gt; &lt;Button android:id=\"@+id/btn_del\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentEnd=\"true\" android:layout_centerVertical=\"true\" android:layout_marginRight=\"4dp\" android:text=\"Del\" android:textStyle=\"bold\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerHorizontal=\"true\" android:layout_centerVertical=\"true\" android:text=\"Select Coffee\" android:textSize=\"18dp\" android:textStyle=\"bold\" /&gt; 12345678910111213141516171819202122232425// activity 소스 중 일부Button btnReset;Button btnAdd;Button btnDel;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.your_view); btnReset = findViewById(R.id.btn_reset); btnAdd = findViewById(R.id.btn_add); btnDel = findViewById(R.id.btn_del); btnReset.setOnClickListener(mClickListener); btnAdd.setOnClickListener(mClickListener); btnDel.setOnClickListener(mClickListener);&#125;Button.OnClickListener mClickListener = new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //pass &#125;&#125;; 소스를 보기만 해도 답답하다. class 내부에서 변수를 선언해주고 id를 가져와서 연결해주고 listener를 연결한다. 하나의 element마다 3줄을 써야되는 것이다. 그렇다면 이와 같은 것을 제거하기 위해 라이브러리를 사용한다면 어떻게 될까? -- ButterKnife를 사용하였을 경우이 글의 작성 시점 2017-05-11 에는 버터나이프보다 Data Binding이 좀 더 좋은 평을 얻고있다. android 자체적으로 지원하는 라이브러리에 Data Binding이 추가되어 있는 상태이다. ButterKnife로 소스를 간결하게 하는 법을 소개한다. 사용하는 소스는 ButterKnife 공식 홈페이지 ButterKnife을 참고하자. 1. gradle setting app의 build.gradle에 다음 소스를 추가한다. 우리가 주목해야 하는 부분은 아래와 같다. apply plugin: ‘android-apt’compile ‘com.jakewharton:butterknife:8.5.1’apt ‘com.jakewharton:butterknife-compiler:8.5.1’ testCompile ‘junit:junit:4.12’ 12345678910111213141516// app\\build.gradle 중 일부apply plugin: 'android-apt'dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:25.3.1' compile 'com.android.support.constraint:constraint-layout:1.0.2' compile 'com.jakewharton:butterknife:8.5.1' apt 'com.jakewharton:butterknife-compiler:8.5.1' testCompile 'junit:junit:4.12'&#125; project의 build.gradle에 다음 소스를 추가한다. 우리가 주목해야 할 부분은 아래와 같다. classpath ‘com.neenbedankt.gradle.plugins:android-apt:1.8’ 12345678910111213// build.gradle 중 일부buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.1' classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 2. example아래 소스를 보면 ButterKnife.bind(this);라는 부분에서 지금 사용하는 Activity의 layout(xml)에 해당하는 부분을 바인딩하고 @BindView에서 id를 연결해 주는 모습이다. 이는 class 내부에서 사용할 때 변수 선언을 해주고 안드로이드의 생명 주기상 onCreate할 때 데이터를 바인딩 해줘야하는 두줄의 소스를 한줄로 줄이는 것으로 볼 수 있다. 123456789101112class ExampleActivity extends Activity &#123; @BindView(R.id.title) TextView title; @BindView(R.id.subtitle) TextView subtitle; @BindView(R.id.footer) TextView footer; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); ButterKnife.bind(this); // TODO Use fields... &#125;&#125; 아래와 같이 여러 view의 listener도 bind한번으로 가능하게 한다.12345678@OnClick(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)public void pickDoor(DoorView door) &#123; if (door.hasPrizeBehind()) &#123; Toast.makeText(this, \"You win!\", LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(this, \"Try again\", LENGTH_SHORT).show(); &#125;&#125; -- Data Binding 사용하였을 경우Data Binding은 AndroidSDK에서 지원하기 때문에 공식 API문서를 참고한다 Data Binding 1. gradle setting app의 build.gradle에 다음 소스를 추가한다. 1234567// app\\build.gradle 중 일부android &#123; .... dataBinding &#123; enabled = true &#125;&#125; 2. example아래 xml파일에서 기존 xml과 다른 부분을 찾자면 tag와 tag와 android:text=”@{user.firstName}” 이 될 것이다. Data Binding을 사용하기 위해서는 LinearLayout과 같은 사용자의 View를 으로 감싸고 그 뒤에 data요소와 view요소를 추가한다. 레이아웃 내에서 @{}를 통해서 속성을 불러올 수 있다. 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;user.firstName&#125;\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;user.lastName&#125;\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 12345678public class User &#123; public final String firstName; public final String lastName; public User(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 이제 activity에서 바인딩을 해주면 된다.1234567@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); User user = new User(\"Test\", \"User\"); binding.setUser(user);&#125; 더 자세한 내용은 위에 링크한 안드로이드 공식 문서를 찾아보면 된다. Data Binding, ButterKnife 후기 데이터 바인딩을 해주는 것으로 소스를 좀더 간결하게 사용 할 수 있다. 아직까지는 버터나이프를 사용하고 있는데, Data Binding도 익숙해지도록 노력해야겠다.","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://clucle.github.io/tags/android/"}]},{"title":"Hexo를 이용한 GitHub Blog 만들기","slug":"My-New-Post","date":"2017-04-20T16:46:44.000Z","updated":"2017-04-27T13:17:56.629Z","comments":true,"path":"2017/04/21/My-New-Post/","link":"","permalink":"http://clucle.github.io/2017/04/21/My-New-Post/","excerpt":"","text":"Hexo란 간편하게 만들 수 있는 블로그 프레임 워크다. 더 많은 정보는 공식 홈페이지 Hexo 에서 볼 수 있다. Hexo로 블로그를 만드는 방법을 소개 하려 글을 쓴다. Hexo를 사용해서 깃에 블로그를 만들기 위해서는 github 계정이 있어야 하고, node가 깔려한다. 링크를 타고 가서 nodejs를 다운받을 수 있다. github Repository 만들기GitHub 에서는 GitHub Repository에서 웹을 호스팅 할수 있는 기능을 제공 한다. 더 많은 정보는 공식 홈페이지 GitHub Pages 에서 볼 수 있다. 우선 Repository를 만들어야 한다. 이미 주소가 있기 때문에 빨간 경고창이 나오지만 처음이라면 경고창이 나오지 않을테니 [username].github.io 로 Repository로 만들면 된다. Public, Private는 블로그에는 영향을 주지 않는다. 이제 Create repository를 눌러서 Repository를 생성한다. Hexo 설치Hexo를 설치하기 위해 윈도우에서는 Git 에서 다운받을 수 있는 GitBash를 사용할 것이다. 링크 한 홈페이지에 들어가서 Download를 하고 끝가지 설치 하면 GitBash가 깔릴 것이다. 아래는 gitbash 화면이다. 이제 hexo를 다음 명령어를 입력해서 설치한다. git bash에서 가만히 멈춰 있는 것 처럼 보여도 다운받는 과정이다.1$ npm install -g hexo-cli 아래는 설치가 완료된 모습이다. 이제 다운받은 hexo를 이용해서 블로그의 내용이 담길 폴더를 생성하고 초기화 해준다.1$ hexo init (your_blog_name) 아래는 초기화가 완료된 모습이다. hexo init 까지 마치면 명령을 실행한 폴더 안에 (your_blog_name) 이라는 폴더가 생긴다. 이 폴더에 들어가서 로컬에서 hexo가 어떻게 보여지는지 확인 할 수 있다. hexo server를 실행 후 localhost:4000 으로 들어가서 확인해보자.12$ cd your_blog_name$ hexo server Deploy 설정하기Deployt란 배포를 뜻하고 방금 로컬에서 테스트한 서버를 github 블로그에 들어갔을 때 보여지게 하는 과정이다. Hexo에서는 Deploy기능을 제공해 주는데 우리는 위에서 만든 github Repository 주소를 지정해주면 Deploy시 자동으로 commit 과 push가 되면서 블로그가 갱신된다. 그래서 개인 설정을 해야하는데 개인 설정은 (your_blog_name)의 _config.yml 을 수정하면 된다.1$ vi _config.yml 우리가 수정할 부분은 #Site, #URL, #Deployment 이다. #Site 에서는 title에 블로그 제목, subtitle에 문구, description에 설명, author에 이름, language에 언어를 적어준다. 이 부분은 홈페이지에 보이는 내용들을 수정 할 수 있다. #URL 에서는 url 부분을 github Repository의 git 주소를 적어둔다 https://github.com/[username]/[username].github.io.git #Deployment 에서는 github주소와 어떤 브랜치에 올릴지 정하는데 우린 master브랜치로 하면 된다. GitHub에 Deploy하기이제 설정은 마쳤고 github에 배포만 해주면 된다. 배포를 하기 위해서 hexo-deploy-git을 설치한다. 작업하고 있던 (your_blog_name) 폴더 안에서 명령어를 실행한다.1$ npm install --save hexo-deployer-git 설치를 마친 후 배포하는 명령을 실행한다.12$ hexo generate$ hexo deploy deploy 후 [username].github.io 에 들어가면 GitHub Blog가 완성된다. Hexo 후기 블로그 포스팅은 github에 저장 되지만 블로그 내용을 담고 있는 폴더 (your_blog_name) 을 따로 관리해 주어야 한다. 블로그 테마 바꾸는 법은 후에 포스팅 하겠다.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://clucle.github.io/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-04-20T05:45:41.170Z","updated":"2017-04-20T05:31:18.617Z","comments":true,"path":"2017/04/20/hello-world/","link":"","permalink":"http://clucle.github.io/2017/04/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}